<# 
	// This  template is used to generate service calsses from operation classes (implementing Ziv.ServiceModel.IOperation)
	// To use, add an @assembly reference to the file containing your operation calsses and includ this as a @include in a tt file in your project
#>
<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly name="$(TargetDir)Ziv.ServiceModel.CodeGeneration.dll" #>
<#@ import namespace="Ziv.ServiceModel.CodeGeneration" #>
<#@ output extension=".cs" #>
<# //System.Diagnostics.Debugger.Launch(); #>
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//     (c) Ziv Systems 2015
//
//      !!!   DO NOT CHANGE - This code was generated by a tool. Changes would be reverted by regeneration   
//
//      This code contains service classes for Operations implementing IOperation<T>.
//      Operations calsses must have a single constructor. All constructor parameters before IOperationsManager
//      are considered parameters of the operation to be provided upon call. All parmeters after are
//      considerd services to be injected to service class.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
<# 
    var operationCalsses=OperationsCodeGenerationUtils.GetOperationServiceClasses();
    foreach (var classData in operationCalsses)
    {
        string servicesDecleration=classData.RequierdServices.ToDecleration();
#>

namespace <#=classData.ClassNamespace#> 
{
<#
        foreach (var ns in classData.RequiredNamespaces.OrderBy(ns=>ns))       
        {
#>
    using <#=ns.ToString()#>;
<#
        } 
#>

    public sealed class <#=classData.ClassName#> : <#=classData.ServiceBaseClassName#>, <#=classData.ImplementedServiceInterfaces#>
    {
<#            
        foreach (var srvc in classData.RequierdServices)
        {
#>
        private readonly <#=srvc.ParameterType.Name#> <#=srvc.ToPrivateValirableName()#>;
<#
        } 
#>

        public <#=classData.ClassName#>(<#=servicesDecleration#>)
            : base(operationsManager)
        {
<#
        foreach (var srvc in classData.RequierdServices)
        {
#>
            <#=srvc.ToPrivateValirableName()#> = <#=srvc.Name#>;
<#
        }
#>
        }
<#
        foreach (Type operationType in classData.OperationsTypes)
        {
            string shortName=operationType.OperationShortName();
            string resultTypeName=operationType.OperationResultType().Name;
            string parametersDecleration=operationType.OperationParameters().ToDecleration();
            string parametersInvocation=operationType.OperationParameters().ToInvocation();
            string getOperationMethodName="GetOperation"+shortName;
 #>
   
        #region Operation <#=shortName#>

<# 
            if (operationType.OperationIsGeneratingSyncMethod())
            {
                if (!operationType.OperationIsReturningVoid())
                {
#>
        public <#=resultTypeName#> <#=shortName#>(<#=parametersDecleration#>)
        {
            return (<#=resultTypeName#>)DoOperation(<#=getOperationMethodName#>(<#=parametersInvocation#>)).Result;
        }
<# 
                }
                else
                {
#>
		public void <#=shortName#>(<#=parametersDecleration#>)
        {
            DoOperation(<#=getOperationMethodName#>(<#=parametersInvocation#>));
        }
<#
                }
            }
#>
<#
            if (operationType.OperationIsGeneratingAsyncMethods())
            {
#>

		public OperationStartInformation <#=shortName#>Async(<#=parametersDecleration#>)
        {
            return DoOperationAsync(<#=getOperationMethodName#>(<#=parametersInvocation#>));
        }

        public OperationStatus<<#=resultTypeName#>> <#=shortName#>GetStatus(Guid operationId)
        {
            return GetOperationStatus(operationId).ToTypedStatus<<#=resultTypeName#>>();
        }

        public void <#=shortName#>Cancel(Guid operationId)
        {
            CancelOperation(operationId);
        }
<#
            }
#>

        private <#=operationType.Name#> <#=getOperationMethodName#>(<#=parametersDecleration#>)
        {
            return new <#=operationType.Name#>(<#=operationType.OperationConstructorInvocation()#>);
        }

        #endregion

<#
        }
#>
    }
}

<#
    }
#>